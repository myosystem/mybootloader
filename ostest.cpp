void main();
extern "C" void _start() {
    main();
    return;
}
typedef unsigned short uint16_t;
typedef unsigned char uint8_t;
typedef unsigned int uint32_t;
typedef unsigned long long uint64_t;
typedef signed short int16_t;
typedef signed char int8_t;
typedef signed int int32_t;
typedef signed long long int64_t;
typedef struct {
    uint64_t framebufferAddr;
    uint32_t framebufferWidth;
    uint32_t framebufferHeight;
    uint32_t framebufferPitch;
    void* rsdp;
} BootInfo;
typedef struct {
    uint64_t gbuffer;
    uint32_t width;
    uint32_t height;
} Frame;
static int seed = 123456789;
int simple_rand() {
    seed ^= seed << 13;
    seed ^= seed >> 17;
    seed ^= seed << 5;
    return seed;
}
#define KEY_ESC        (char)0x1B
#define KEY_RETURN     (char)0x0D
#define KEY_TAB        (char)0x09
#define KEY_BACKSPACE  (char)0x08
#define KEY_SPACE      (char)0x20
#define KEY_LSHIFT     (char)0xA0
#define KEY_RSHIFT     (char)0xA1
#define KEY_LCONTROL   (char)0xA2
#define KEY_RCONTROL   (char)0xA3
#define KEY_LMENU      (char)0xA4
#define KEY_RMENU      (char)0xA5
#define KEY_CAPITAL    (char)0x14
#define KEY_NUMLOCK    (char)0x90
#define KEY_SCROLL     (char)0x91
#define KEY_INSERT     (char)0x2D
#define KEY_DELETE     (char)0x2E
#define KEY_HOME       (char)0x24
#define KEY_END        (char)0x23
#define KEY_PAGEUP     (char)0x21
#define KEY_PAGEDOWN   (char)0x22
#define KEY_UP         (char)0x26
#define KEY_DOWN       (char)0x28
#define KEY_LEFT       (char)0x25
#define KEY_RIGHT      (char)0x27
#define KEY_F1         (char)0x70
#define KEY_F2         (char)0x71
#define KEY_F3         (char)0x72
#define KEY_F4         (char)0x73
#define KEY_F5         (char)0x74
#define KEY_F6         (char)0x75
#define KEY_F7         (char)0x76
#define KEY_F8         (char)0x77
#define KEY_F9         (char)0x78
#define KEY_F10        (char)0x79
#define KEY_F11        (char)0x7A
#define KEY_F12        (char)0x7B
#define KEY_PAUSE      (char)0x92
unsigned char font8x8_basic[128][8] = {
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0000 (nul)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0001
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0002
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0003
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0004
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0005
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0006
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0007
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0008
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0009
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000A
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000B
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000C
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000D
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000E
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000F
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0010
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0011
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0012
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0013
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0014
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0015
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0016
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0017
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0018
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0019
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001A
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001B
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001C
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001D
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001E
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001F
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0020 (space)
    { 0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00},   // U+0021 (!)
    { 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0022 (")
    { 0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00},   // U+0023 (#)
    { 0x0C, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x0C, 0x00},   // U+0024 ($)
    { 0x00, 0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00},   // U+0025 (%)
    { 0x1C, 0x36, 0x1C, 0x6E, 0x3B, 0x33, 0x6E, 0x00},   // U+0026 (&)
    { 0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0027 (')
    { 0x18, 0x0C, 0x06, 0x06, 0x06, 0x0C, 0x18, 0x00},   // U+0028 (()
    { 0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, 0x00},   // U+0029 ())
    { 0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00},   // U+002A (*)
    { 0x00, 0x0C, 0x0C, 0x3F, 0x0C, 0x0C, 0x00, 0x00},   // U+002B (+)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x06},   // U+002C (,)
    { 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00},   // U+002D (-)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00},   // U+002E (.)
    { 0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00},   // U+002F (/)
    { 0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00},   // U+0030 (0)
    { 0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00},   // U+0031 (1)
    { 0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00},   // U+0032 (2)
    { 0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00},   // U+0033 (3)
    { 0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00},   // U+0034 (4)
    { 0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00},   // U+0035 (5)
    { 0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00},   // U+0036 (6)
    { 0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00},   // U+0037 (7)
    { 0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00},   // U+0038 (8)
    { 0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00},   // U+0039 (9)
    { 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00},   // U+003A (:)
    { 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x06},   // U+003B (;)
    { 0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00},   // U+003C (<)
    { 0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00},   // U+003D (=)
    { 0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00},   // U+003E (>)
    { 0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00},   // U+003F (?)
    { 0x3E, 0x63, 0x7B, 0x7B, 0x7B, 0x03, 0x1E, 0x00},   // U+0040 (@)
    { 0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00},   // U+0041 (A)
    { 0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00},   // U+0042 (B)
    { 0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00},   // U+0043 (C)
    { 0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00},   // U+0044 (D)
    { 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00},   // U+0045 (E)
    { 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00},   // U+0046 (F)
    { 0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00},   // U+0047 (G)
    { 0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00},   // U+0048 (H)
    { 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0049 (I)
    { 0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00},   // U+004A (J)
    { 0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00},   // U+004B (K)
    { 0x0F, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7F, 0x00},   // U+004C (L)
    { 0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00},   // U+004D (M)
    { 0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00},   // U+004E (N)
    { 0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00},   // U+004F (O)
    { 0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00},   // U+0050 (P)
    { 0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00},   // U+0051 (Q)
    { 0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00},   // U+0052 (R)
    { 0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00},   // U+0053 (S)
    { 0x3F, 0x2D, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0054 (T)
    { 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00},   // U+0055 (U)
    { 0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00},   // U+0056 (V)
    { 0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00},   // U+0057 (W)
    { 0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00},   // U+0058 (X)
    { 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00},   // U+0059 (Y)
    { 0x7F, 0x63, 0x31, 0x18, 0x4C, 0x66, 0x7F, 0x00},   // U+005A (Z)
    { 0x1E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x1E, 0x00},   // U+005B ([)
    { 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00},   // U+005C (\)
    { 0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00},   // U+005D (])
    { 0x08, 0x1C, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00},   // U+005E (^)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF},   // U+005F (_)
    { 0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0060 (`)
    { 0x00, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00},   // U+0061 (a)
    { 0x07, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3B, 0x00},   // U+0062 (b)
    { 0x00, 0x00, 0x1E, 0x33, 0x03, 0x33, 0x1E, 0x00},   // U+0063 (c)
    { 0x38, 0x30, 0x30, 0x3e, 0x33, 0x33, 0x6E, 0x00},   // U+0064 (d)
    { 0x00, 0x00, 0x1E, 0x33, 0x3f, 0x03, 0x1E, 0x00},   // U+0065 (e)
    { 0x1C, 0x36, 0x06, 0x0f, 0x06, 0x06, 0x0F, 0x00},   // U+0066 (f)
    { 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x1F},   // U+0067 (g)
    { 0x07, 0x06, 0x36, 0x6E, 0x66, 0x66, 0x67, 0x00},   // U+0068 (h)
    { 0x0C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0069 (i)
    { 0x30, 0x00, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E},   // U+006A (j)
    { 0x07, 0x06, 0x66, 0x36, 0x1E, 0x36, 0x67, 0x00},   // U+006B (k)
    { 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+006C (l)
    { 0x00, 0x00, 0x33, 0x7F, 0x7F, 0x6B, 0x63, 0x00},   // U+006D (m)
    { 0x00, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x00},   // U+006E (n)
    { 0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00},   // U+006F (o)
    { 0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x0F},   // U+0070 (p)
    { 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x78},   // U+0071 (q)
    { 0x00, 0x00, 0x3B, 0x6E, 0x66, 0x06, 0x0F, 0x00},   // U+0072 (r)
    { 0x00, 0x00, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x00},   // U+0073 (s)
    { 0x08, 0x0C, 0x3E, 0x0C, 0x0C, 0x2C, 0x18, 0x00},   // U+0074 (t)
    { 0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x6E, 0x00},   // U+0075 (u)
    { 0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00},   // U+0076 (v)
    { 0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00},   // U+0077 (w)
    { 0x00, 0x00, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x00},   // U+0078 (x)
    { 0x00, 0x00, 0x33, 0x33, 0x33, 0x3E, 0x30, 0x1F},   // U+0079 (y)
    { 0x00, 0x00, 0x3F, 0x19, 0x0C, 0x26, 0x3F, 0x00},   // U+007A (z)
    { 0x38, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x38, 0x00},   // U+007B ({)
    { 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00},   // U+007C (|)
    { 0x07, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0x07, 0x00},   // U+007D (})
    { 0x6E, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+007E (~)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}    // U+007F
};
char scan_code_table[] = {
    (char)0, KEY_ESC, '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=', '\b',
    '\t', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', '[', ']', KEY_RETURN,
    KEY_LCONTROL, 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';', '\'', '`',
    KEY_LSHIFT, '\\', 'z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '.', '/', KEY_RSHIFT,
    KEY_RCONTROL, KEY_LMENU, ' ', (char)0, KEY_CAPITAL,
    KEY_F1, KEY_F2, KEY_F3, KEY_F4, KEY_F5, KEY_F6, KEY_F7, KEY_F8, KEY_F9, KEY_F10,
    KEY_F11, KEY_F12, (char)0, (char)0, (char)0, (char)0, (char)0, KEY_SCROLL, KEY_PAUSE, (char)0, (char)0, (char)0,
    KEY_INSERT, KEY_HOME, KEY_PAGEUP, (char)0, KEY_DELETE, KEY_END, KEY_PAGEDOWN, (char)0,
    KEY_UP, (char)0, KEY_LEFT, (char)0, KEY_RIGHT, (char)0, KEY_DOWN
};
volatile int kbd_state[256] = {
    0,
};
typedef struct {
    char Signature[8];
    uint8_t Checksum;
    char OEMID[6];
    uint8_t Revision;
    uint64_t RsdtAddress;
} __attribute__((packed)) RSDPDescriptor;

typedef struct {
    char Signature[4];
    uint32_t Length;
    uint8_t Unused1[76];
    uint32_t PM1aControlBlock;
} __attribute__((packed)) FADT;

void* find_fadt(void* rsdp_addr) {
    RSDPDescriptor *rsdp = (RSDPDescriptor *)rsdp_addr;
    uint64_t rsdt_addr = rsdp->RsdtAddress;

    char *rsdt = (char *)rsdt_addr;
    int entry_count = (*(uint32_t *)(rsdt + 4) - 36) / 4;

    for (int i = 0; i < entry_count; i++) {
        uint64_t *entry = (uint64_t *)(rsdt + 36 + i * 8);  // Use uint64_t for 64-bit addresses
        char *table = (char *)(*entry);

        if (*(uint32_t *)table == 0x50434146) {  // "FACP"
            return (void*)table;
        }
    }
    return 0;
}
void outb(uint16_t port, uint8_t value) {
    __asm__ __volatile__ (
        "mov dx, %0;"
        "mov al, %1;"
        "out dx, al;"
        :
        : "r" (port), "r" (value)
        : "dx", "al"
    );
}

static inline uint8_t inb(uint16_t port) {
    uint8_t ret;
    __asm__ __volatile__ (
        "mov dx, %1;"
        "xor eax, eax;"
        "in al, dx;"
        "mov %0, al;"
        : "=r" (ret)
        : "r" (port)
        : "eax", "edx"
    );
    return ret;
}
void putc(Frame f,int x,int y,char text,uint32_t color,int scale) {
    if(text < 32 || text > 127) return;
    for(int row = 0;row < 8;row++) {
        uint8_t bits = font8x8_basic[(int)text][row];
        for(int col = 0;col < 8;col++) {
            if(bits & (1 << (7 - col))) {
                for(int y_offset = 0;y_offset < scale;y_offset++) {
                    for(int x_offset = 0;x_offset < scale;x_offset++) {
                        ((uint32_t*)(f.gbuffer))[(int)f.width * (y + row * scale + y_offset) + (x + col * scale + x_offset)] = color;
                    }
                }
            }
        }
    }
}
void shutdown(void* rsdp_addr) {
    void* fadt_addr = find_fadt(rsdp_addr);
    if (fadt_addr == 0) return;

    FADT *fadt = (FADT *)fadt_addr;
    uint32_t pm1a_control = fadt->PM1aControlBlock;

    outb((uint16_t)(pm1a_control),(uint8_t)((5 << 10) | (1 << 13)));
}
#define PIC1_CMD  0x20
#define PIC1_DATA 0x21
#define KEYBOARD_DATA_PORT 0x60

#define IDT_SIZE 256
struct idt_entry {
    uint16_t offset_low;
    uint16_t selector;
    uint8_t zero;
    uint8_t type_attr;
    uint16_t offset_middle;
    uint32_t offset_high;
    uint32_t reserved;
} __attribute__((packed));

struct idt_ptr {
    uint16_t limit;
    uint64_t base;
} __attribute__((packed));

idt_entry idt[IDT_SIZE] __attribute__((aligned(16)));
idt_ptr idt_reg;
void set_idt_gate(int n, uint64_t handler, uint16_t selector, uint8_t flags) {
    idt[n].offset_low = handler & 0xFFFF;
    idt[n].offset_middle = (handler >> 16) & 0xFFFF;
    idt[n].offset_high = (handler >> 32) & 0xFFFFFFFF;
    idt[n].selector = selector;
    idt[n].zero = 0;
    idt[n].type_attr = flags;
}
void load_idt(idt_ptr* _idt_ptr) {
    __asm__ __volatile__ (
        "lidt [%0];"
        : : "r"(_idt_ptr) : "memory"
    );
}
void load_idt() {
    idt_reg.limit = (sizeof(struct idt_entry) * IDT_SIZE) - 1;
    idt_reg.base = (uint64_t)&idt;
    load_idt(&idt_reg);
}
char inputkey = 0;
extern "C" void keyboard_handler() {
    __asm__ __volatile__(
        "cli;"
        "leave;"
    );
    uint8_t scancode = inb(KEYBOARD_DATA_PORT);
    if(scancode == 0xe0) {
        scancode = inb(KEYBOARD_DATA_PORT);
    }
    if(scancode & 0x80) {
        scancode -= 0x80;
        kbd_state[scan_code_table[scancode]] = 0;
    }
    else {
        kbd_state[scan_code_table[scancode]] = 1;
    }
    inputkey = scan_code_table[scancode];
    //shutdown(gGraphicsInfo->rsdp);
    outb(PIC1_CMD, 0x20);
    __asm__ __volatile__ (
        "sti;"        // 인터럽트 활성화
        "iretq;"        // 인터럽트 종료
    );
}
char test = 0;
uint64_t add1;
void ttest() {
    __asm__ __volatile__("adroop:");
    __asm__ __volatile__(
        "add %[add1], 1;"
        : [add1] "=r" (test)
        :
        :
    );
    __asm__ __volatile__("jmp adroop");
}
uint64_t add2;
bool is1 = true;
uint64_t old_return_address;
uint64_t new_return_address;
uint64_t old_stack_address;
uint64_t new_stack_address;
uint64_t stack1;
uint8_t teststack[0x10000] = {};
uint64_t stack2 = (uint64_t)teststack + 0x10000;
extern "C" void timer_handler() {
    new_return_address = is1 ? add2 : add1;
    new_stack_address = is1? stack2 : stack1;
    __asm__ __volatile__(
        "cli;"
        "leave;"
        "mov rax, rsp;"
        "mov rsp, %[new_stack];"
        "sub rsp, 40;"
        "mov rbx, [rax];"
        "mov [rsp], rbx;"
        "mov rbx, [rax + 8];"
        "mov [rsp + 8], rbx;"
        "mov rbx, [rax + 16];"
        "mov [rsp + 16], rbx;"
        "mov rbx, [rax + 24];"
        "mov [rsp + 24], rbx;"
        "mov rbx, [rax + 32];"
        "mov [rsp + 32], rbx;"
        "mov %[old], [rsp];"
        "mov [rsp], %[newa];"
        "add rax, 40;"
        "mov %[old_stack], rax;"
        : [old] "=r" (old_return_address), [old_stack] "=m" (old_stack_address)
        : [new_stack] "r" (new_stack_address),[newa] "r" (new_return_address)
        : "memory", "rax"
    );
    if (is1) {
        add1 = old_return_address;
        stack1 = old_stack_address;
    } else {
        add2 = old_return_address;
        stack2 = old_stack_address;
    }
    is1 = !is1;
    outb(PIC1_CMD, 0x20);
    __asm__ __volatile__ (
        "sti;"        // 인터럽트 활성화
        "iretq;"        // 인터럽트 종료
    );
}
extern "C" void none_handler() {
    outb(PIC1_CMD, 0x20);
    __asm__ __volatile__ (
        "leave;"
        "nop;"
        "iretq;"        // 인터럽트 종료
    );
}
volatile int cursor_x = 200;
volatile int cursor_y = 200;
extern "C" void cursor_handler() {
    __asm__ __volatile__(
        "cli;"
        "leave;"
    );
    static uint8_t cycle = 0;
    static uint8_t cursor_bytes[3];

    cursor_bytes[cycle] = inb(0x60);
    if(cycle == 0 && !(cursor_bytes[0] & 0x08));
    else if (++cycle == 3) { // 3바이트 패킷 수신 완료
        cycle = 0;

        uint8_t dx = cursor_bytes[1]; // X 이동 값
        uint8_t dy = cursor_bytes[2]; // Y 이동 값 (위-아래 반전)
        int8_t x_sign = (cursor_bytes[0] & 0x10) >> 4;  // X 부호 비트 (비트 3)
        int8_t y_sign = (cursor_bytes[0] & 0x20) >> 5;
        if((cursor_bytes[0] >> 6) & 1) cursor_x += x_sign ? -255 : 255;
        else if (x_sign) cursor_x -= (uint8_t)(dx * -1);
        else cursor_x += dx;
        
        if(cursor_bytes[0] >> 7) cursor_y += y_sign ? -255 : 255;
        else if (y_sign) cursor_y += (uint8_t)(dy * -1);
        else cursor_y -= dy;
        BootInfo* gGraphicsInfo = (BootInfo*)0x10000000;
        if (cursor_x < 0) cursor_x = 0;
        if (cursor_y < 0) cursor_y = 0;
        if (cursor_x >= gGraphicsInfo->framebufferWidth) cursor_x = gGraphicsInfo->framebufferWidth - 1;
        if (cursor_y >= gGraphicsInfo->framebufferHeight) cursor_y = gGraphicsInfo->framebufferHeight - 1;
    }
    outb(0xA0, 0x20); // 인터럽트 종료 신호
    outb(0x20, 0x20); // 인터럽트 종료 신호
    __asm__ __volatile__ (
        "sti;"        // 인터럽트 활성화
        "iretq;"        // 인터럽트 종료
    );
}
void wait_for_input_buffer() {
    while (inb(0x64) & 0b00000010);  // 입력 버퍼가 찼으면 대기
}

// 출력 버퍼에 데이터가 들어올 때까지 대기
void wait_for_output_buffer() {
    while (!(inb(0x64) & 0b00000001));  // 데이터가 올 때까지 대기
}

// PS/2 컨트롤러에서 마우스 활성화 및 인터럽트 설정
void enable_cursor() {
    outb(0x64, 0xA8); // 마우스 활성화
    outb(0x64, 0x20); // 컨트롤러 설정 읽기
    uint8_t status = inb(0x60) | 2; // IRQ12 활성화
    outb(0x64, 0x60);
    outb(0x60, status);

    // 마우스 설정
    outb(0x64, 0xD4);
    outb(0x60, 0xF4); // 마우스 데이터 전송 활성화
}
void init_pic() {
    outb(PIC1_CMD, 0x11);
    outb(0xA0, 0x11);
    outb(PIC1_DATA, 0x20);
    outb(0xA1, 0x28);
    outb(PIC1_DATA, 4);
    outb(0xA1, 2);
    outb(PIC1_DATA, 0x01);
    outb(0xA1, 0x01);
    outb(PIC1_DATA, 0);
    outb(0xA1, 0);
}
void init_interrupts() {
    asm volatile ("cli");
    init_pic();
    enable_cursor();
    for(int i = 0;i<IDT_SIZE;i++) {
        if(i != 33 && i != 44 && i != 32)
            set_idt_gate(i, (uint64_t)none_handler, 0x08, 0x8E);
    }
    set_idt_gate(32, (uint64_t)timer_handler, 0x08, 0x8E);
    set_idt_gate(33, (uint64_t)keyboard_handler, 0x08, 0x8E);
    set_idt_gate(44, (uint64_t)cursor_handler, 0x08, 0x8E);
    load_idt();
    asm volatile ("sti");
}
void main() {
    __asm__ __volatile__(
        "mov %[add1], adroop;"
        : [add1] "=r" (add2)
        :
        :
    );
    unsigned int i;
    init_interrupts();
    BootInfo* gGraphicsInfo = (BootInfo*)0x10000000;
    for (i = 0; i < gGraphicsInfo->framebufferWidth * gGraphicsInfo->framebufferHeight; i++) {
        uint8_t Red = 255;
        uint8_t Green = 255;
        uint8_t Blue = 255;

        uint32_t PixelColor = (Red << 16) | (Green << 8) | Blue;
        *((uint32_t*)(gGraphicsInfo->framebufferAddr) + i) = PixelColor;
    }
    Frame mainframe = {0x20000000,gGraphicsInfo->framebufferWidth,gGraphicsInfo->framebufferHeight};
    while(1) {
        for (int i = 0; i < mainframe.width * mainframe.height; i++) {
            *((uint32_t*)(mainframe.gbuffer) + i) = -1u;
        }
        for(int y = -50; y < 50; y++) {
            for(int x = -50; x < 50; x++) {
                if(cursor_x + x >= 0 && cursor_x + x < gGraphicsInfo->framebufferWidth && gGraphicsInfo->framebufferHeight - cursor_y - y >= 0 && gGraphicsInfo->framebufferHeight - cursor_y - y < gGraphicsInfo->framebufferHeight) {
                    ((uint32_t*)(mainframe.gbuffer))[(int)gGraphicsInfo->framebufferWidth * (cursor_y + y) + (cursor_x + x)] = 0;
                }
            }
        }
        putc(mainframe,10,10,inputkey,0,10);
        putc(mainframe,10,30,test,0,10);
        for (int i = 0; i < gGraphicsInfo->framebufferWidth * gGraphicsInfo->framebufferHeight; i++) {
            *((uint32_t*)(gGraphicsInfo->framebufferAddr) + i) = *((uint32_t*)(0x20000000) + i);
        }
    }
}